<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poincaré Disk Inversion</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
        }

        #toolbar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 50px;
            background-color: #f0f0f0;
            border-right: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 10px;
            z-index: 10;
            transition: left 0.3s ease;
        }
        
        body.toolbar-closed #toolbar {
            left: -51px;
        }

        #toolbar-toggle {
            position: fixed;
            left: 50px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 50px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-left: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0 5px 5px 0;
            z-index: 11;
            transition: left 0.3s ease;
        }
        
        body.toolbar-closed #toolbar-toggle {
            left: 0;
            border-left: 1px solid #ccc;
        }


        .tool-button {
            width: 32px;
            height: 32px;
            margin-bottom: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #fff;
            flex-shrink: 0;
        }

        .tool-button:hover {
            border-color: #999;
        }

        .tool-button.active {
            border-color: #007bff;
            background-color: #e0efff;
        }

        .tool-button#reset-button {
            margin-top: auto;
        }

        .tool-button svg {
            width: 24px;
            height: 24px;
        }
        
        #content-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            padding-left: 50px; /* Toolbar width */
            transition: padding-left 0.3s ease;
            position: relative;
        }
        
        body.toolbar-closed #content-wrapper {
            padding-left: 20px; /* Toggle button width */
        }
        
        body.integrated-view #output-view {
            display: none;
        }
        
        body.integrated-view #input-view {
            border-right: none;
        }
        
        .inverted-object {
            pointer-events: none;
        }

        .view {
            flex: 1;
            height: 100%;
            border-left: 1px solid #eee;
            position: relative;
        }
        
        .view:first-child {
            border-left: none;
        }

        .view svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .view-label {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            color: #555;
            pointer-events: none;
        }

        .color-picker-wrapper {
            position: absolute;
            right: 15px;
            bottom: 15px;
            z-index: 5;
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .color-picker-popup {
            display: none;
            flex-direction: column;
            gap: 4px;
            position: absolute;
            bottom: 30px;
            right: 0;
            background-color: white;
            border-radius: 4px;
            padding: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .color-picker-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.2);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .color-picker-input {
            width: 70px;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-family: monospace;
            font-size: 14px;
            text-align: center;
        }
        
        .opacity-slider {
            width: 80px;
            margin: 0;
        }
        
        #output-color-picker-integrated { display: none; }
        body.integrated-view #output-color-picker-integrated { display: block; }
        
        .info-box {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background-color: rgba(0, 0, 0, 0.65);
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 13px;
            pointer-events: none;
            display: none;
            z-index: 5;
        }
        
        #history-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 5px;
        }

        #history-controls button {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 5px;
            cursor: pointer;
        }

        #history-controls button:hover:not(:disabled) {
            background-color: #f0f0f0;
        }
        
        #history-controls button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        #history-controls svg {
            width: 20px;
            height: 20px;
        }
        
        #view-toggle {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow: hidden;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #view-toggle button {
            padding: 5px 15px;
            border: none;
            background-color: #f0f0f0;
            cursor: pointer;
            color: #333;
        }
        #view-toggle button.active {
            background-color: #007bff;
            color: white;
        }


    </style>
</head>
<body>

    <div id="toolbar">
        <div class="tool-button" data-tool="select" title="선택 및 이동 (V)">
            <svg viewBox="0 0 24 24"><path fill="currentColor" d="M9.5,17.5L2,10L10.5,1.5L12.5,3.5L7,9H22V11H7L12.5,16.5L9.5,17.5Z" /></svg>
        </div>
        <div class="tool-button" data-tool="point" title="점 (P)">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="4" fill="currentColor"/></svg>
        </div>
        <div class="tool-button" data-tool="line" title="선 (L)">
            <svg viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="2" fill="none" d="M4 12 L20 12"/></svg>
        </div>
        <div class="tool-button" data-tool="circle" title="원 (C)">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" stroke="currentColor" stroke-width="2" fill="none"/></svg>
        </div>
        <!-- Construction Tools -->
        <div class="tool-button" data-tool="perp_bisector" title="수직이등분선 (두 점 선택)">
            <svg viewBox="0 0 24 24">
                <line x1="3" y1="12" x2="21" y2="12" stroke="currentColor" stroke-width="1.5"/>
                <circle cx="4" cy="12" r="2" fill="currentColor"/>
                <circle cx="20" cy="12" r="2" fill="currentColor"/>
                <line x1="12" y1="3" x2="12" y2="21" stroke="currentColor" stroke-width="1.5" stroke-dasharray="3,2"/>
            </svg>
        </div>
        <div class="tool-button" data-tool="perp_from_point" title="수선 (점에서 직선으로)">
             <svg viewBox="0 0 24 24">
                <line x1="2" y1="18" x2="22" y2="18" stroke="currentColor" stroke-width="1.5"/>
                <circle cx="12" cy="6" r="2" fill="currentColor"/>
                <line x1="12" y1="7" x2="12" y2="17" stroke="currentColor" stroke-width="1.5" stroke-dasharray="3,2"/>
            </svg>
        </div>
        <div class="tool-button" data-tool="perp_on_line" title="수선 (직선 위의 점에서)">
             <svg viewBox="0 0 24 24">
                <line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="1.5"/>
                <circle cx="12" cy="12" r="2" fill="currentColor"/>
                <line x1="12" y1="3" x2="12" y2="21" stroke="currentColor" stroke-width="1.5" stroke-dasharray="3,2"/>
            </svg>
        </div>
        <div class="tool-button" data-tool="angle_bisector" title="각의 이등분선 (세 점 선택)">
            <svg viewBox="0 0 24 24">
                <line x1="12" y1="12" x2="22" y2="18" stroke="currentColor" stroke-width="1.5"/>
                <line x1="12" y1="12" x2="18" y2="2" stroke="currentColor" stroke-width="1.5"/>
                <line x1="12" y1="12" x2="23" y2="10" stroke="currentColor" stroke-width="1.5" stroke-dasharray="3,2"/>
                <circle cx="12" cy="12" r="2" fill="currentColor"/>
            </svg>
        </div>
        <div class="tool-button" data-tool="intersection" title="교점 (I)">
            <svg viewBox="0 0 24 24"><path fill="currentColor" d="M19 12.5a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1 0-1h13a.5.5 0 0 1 .5-.5zM12.5 5a.5.5 0 0 1 .5.5v13a.5.5 0 0 1-1 0v-13a.5.5 0 0 1 .5-.5z"/></svg>
        </div>
        <div class="tool-button" data-tool="delete" title="지우기 (Delete)">
            <svg viewBox="0 0 24 24"><path fill="currentColor" d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
        </div>
        <div class="tool-button" id="reset-button" title="전체 초기화 (R)">
            <svg viewBox="0 0 24 24"><path fill="currentColor" d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" /></svg>
        </div>
    </div>

    <div id="toolbar-toggle">&lt;</div>

    <div id="content-wrapper">
        <div id="view-toggle">
            <button data-mode="split" class="active">분리</button>
            <button data-mode="integrated">통합</button>
        </div>
        <div id="history-controls">
            <button id="undo-btn" title="Undo (Ctrl+Z)">
                <svg viewBox="0 0 24 24"><path fill="currentColor" d="M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z" /></svg>
            </button>
            <button id="redo-btn" title="Redo (Ctrl+Shift+Z)">
                <svg viewBox="0 0 24 24"><path fill="currentColor" d="M18.4,10.6C16.55,9 14.15,8 11.5,8C6.85,8 2.92,11.03 1.53,15.22L3.9,16C4.95,12.81 7.96,10.5 11.5,10.5C13.46,10.5 15.23,11.22 16.62,12.38L13,16H22V7L18.4,10.6Z" /></svg>
            </button>
        </div>
        <div id="input-view" class="view">
            <div class="view-label">입력</div>
            <svg id="input-svg"></svg>
            <div class="color-picker-wrapper">
                <div class="color-picker" id="input-color-picker">
                    <button class="color-picker-btn"></button>
                    <div class="color-picker-popup">
                        <input type="text" class="color-picker-input">
                        <input type="range" class="opacity-slider" min="0" max="1" step="0.05">
                    </div>
                </div>
                <div class="color-picker" id="output-color-picker-integrated">
                    <button class="color-picker-btn"></button>
                    <div class="color-picker-popup">
                        <input type="text" class="color-picker-input">
                        <input type="range" class="opacity-slider" min="0" max="1" step="0.05">
                    </div>
                </div>
            </div>
            <div class="info-box"></div>
        </div>
        <div id="output-view" class="view">
            <div class="view-label">출력 (반전)</div>
            <svg id="output-svg"></svg>
             <div class="color-picker-wrapper">
                <div class="color-picker" id="output-color-picker-split">
                    <button class="color-picker-btn"></button>
                     <div class="color-picker-popup">
                        <input type="text" class="color-picker-input">
                        <input type="range" class="opacity-slider" min="0" max="1" step="0.05">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const inputSvg = document.getElementById('input-svg');
        const outputSvg = document.getElementById('output-svg');
        const toolbar = document.getElementById('toolbar');
        const toggleButton = document.getElementById('toolbar-toggle');
        const contentWrapper = document.getElementById('content-wrapper');
        const resetButton = document.getElementById('reset-button');
        const infoBox = document.querySelector('#input-view .info-box');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const viewToggle = document.getElementById('view-toggle');

        // --- State ---
        let camera = { x: 0, y: 0, zoom: 1 };
        let objects = [];
        let activeTool = 'select';
        let constructionState = { tool: null, step: 0, selections: [], tempPoint: null };
        let snapPoint = null;
        let dragInfo = { target: null, start: null, camera: false, moved: false };
        let nextId = 1; // 0 is reserved for the origin
        let colors = { 
            input: { hex: '#F3E3C3', alpha: 1.0 }, 
            output: { hex: '#00BCD4', alpha: 1.0 } 
        };
        let viewMode = 'split';
        
        let undoStack = [];
        let redoStack = [];

        const INVERSION_RADIUS = 200;
        const INVERSION_CENTER = { x: 0, y: 0 };

        // --- History Management ---
        function updateHistoryButtons() {
            undoBtn.disabled = undoStack.length <= 1; // Can't undo initial state
            redoBtn.disabled = redoStack.length === 0;
        }

        function saveState(force = false) {
            const currentState = JSON.stringify({ objects, nextId });
            if (!force && undoStack.length > 0 && undoStack[undoStack.length - 1] === currentState) {
                return;
            }
            redoStack = [];
            undoStack.push(currentState);
            updateHistoryButtons();
        }

        function undo() {
            if (undoStack.length <= 1) return;
            redoStack.push(undoStack.pop());
            const prevState = JSON.parse(undoStack[undoStack.length - 1]);
            objects = prevState.objects;
            nextId = prevState.nextId;
            render();
            updateHistoryButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const nextStateJSON = redoStack.pop();
            undoStack.push(nextStateJSON);
            const nextState = JSON.parse(nextStateJSON);
            objects = nextState.objects;
            nextId = nextState.nextId;
            render();
            updateHistoryButtons();
        }

        // --- Geometry & Inversion Logic ---
        function getPointById(id) {
            if (id === 0) return { type: 'point', id: 0, x: INVERSION_CENTER.x, y: INVERSION_CENTER.y, dependency: null };
            return objects.find(obj => obj.id === id && obj.type === 'point');
        }
        
        function invertPoint(p) {
            const dx = p.x - INVERSION_CENTER.x, dy = p.y - INVERSION_CENTER.y;
            const distSq = dx * dx + dy * dy;
            if (distSq === 0) return { x: Infinity, y: Infinity };
            const scale = (INVERSION_RADIUS * INVERSION_RADIUS) / distSq;
            return { x: INVERSION_CENTER.x + dx * scale, y: INVERSION_CENTER.y + dy * scale };
        }

        function invertObject(obj) {
             switch (obj.type) {
                case 'point':
                    return { type: 'point', ...invertPoint(obj) };
                case 'line': {
                    const p1 = getPointById(obj.p1Id);
                    const p2 = getPointById(obj.p2Id);
                    if (!p1 || !p2) return { type: 'none' };

                    const isCollinearWithOrigin = Math.abs((p2.y - p1.y) * (INVERSION_CENTER.x - p1.x) - (p2.x - p1.x) * (INVERSION_CENTER.y - p1.y)) < 1e-9;

                    if (isCollinearWithOrigin) {
                        return { type: 'line', p1Id: obj.p1Id, p2Id: obj.p2Id };
                    } else {
                        const p1_inv = invertPoint(p1);
                        const p2_inv = invertPoint(p2);
                        const circleGeom = getCircleFromPoints(p1_inv, p2_inv, INVERSION_CENTER);
                        return { type: 'circle', ...circleGeom };
                    }
                }
                case 'circle': {
                    const center = getPointById(obj.centerId);
                    const radiusPt = getPointById(obj.radiusId);
                    if (!center || !radiusPt) return { type: 'none' };

                    const r = Math.sqrt((radiusPt.x - center.x)**2 + (radiusPt.y - center.y)**2);
                    const cx = center.x;
                    const cy = center.y;
                    
                    const distCenterToOriginSq = (cx - INVERSION_CENTER.x)**2 + (cy - INVERSION_CENTER.y)**2;

                    const isOrthogonal = Math.abs(distCenterToOriginSq - (r * r + INVERSION_RADIUS * INVERSION_RADIUS)) < 1e-5;
                    
                    if (isOrthogonal) {
                        return { type: 'circle', centerId: obj.centerId, radiusId: obj.radiusId };
                    }

                    if (Math.abs(distCenterToOriginSq - r * r) < 1e-6) {
                        const p_diam_opp = { x: 2 * cx - INVERSION_CENTER.x, y: 2 * cy - INVERSION_CENTER.y};
                        const p_inv = invertPoint(p_diam_opp);
                        
                        const norm_dx = cx - INVERSION_CENTER.x;
                        const norm_dy = cy - INVERSION_CENTER.y;

                        const dir_dx = -norm_dy;
                        const dir_dy = norm_dx;

                        const pA = { x: p_inv.x + dir_dx, y: p_inv.y + dir_dy };
                        const pB = { x: p_inv.x - dir_dx, y: p_inv.y - dir_dy };

                        return { type: 'line', p1: pA, p2: pB };
                    } else {
                        const pC_inv = invertPoint({ x: cx + r, y: cy });
                        const pD_inv = invertPoint({ x: cx - r, y: cy });
                        
                        const newCx = (pC_inv.x + pD_inv.x) / 2;
                        const newCy = (pC_inv.y + pD_inv.y) / 2;
                        const newR = Math.sqrt((pC_inv.x - newCx)**2 + (pC_inv.y - newCy)**2);
                        return { type: 'circle', cx: newCx, cy: newCy, r: newR };
                    }
                }
            }
            return { type: 'none' };
        }

        function getCircleFromPoints(p1, p2, p3) {
            const D = 2 * (p1.x*(p2.y - p3.y) + p2.x*(p3.y - p1.y) + p3.x*(p1.y - p2.y));
            if (Math.abs(D) < 1e-9) return { cx: 0, cy: 0, r: Infinity };
            const p1sq = p1.x*p1.x + p1.y*p1.y, p2sq = p2.x*p2.x + p2.y*p2.y, p3sq = p3.x*p3.x + p3.y*p3.y;
            const Ux = (p1sq*(p2.y - p3.y) + p2sq*(p3.y - p1.y) + p3sq*(p1.y - p2.y)) / D;
            const Uy = (p1sq*(p3.x - p2.x) + p2sq*(p1.x - p3.x) + p3sq*(p2.x - p1.x)) / D;
            const r = Math.sqrt((p1.x - Ux)**2 + (p1.y - Uy)**2);
            return { cx: Ux, cy: Uy, r: r };
        }
        
        function screenToWorld(svg, clientX, clientY) {
            const rect = svg.getBoundingClientRect();
            return {
                x: (clientX - rect.left - rect.width / 2) / camera.zoom - camera.x,
                y: (clientY - rect.top - rect.height / 2) / camera.zoom - camera.y
            };
        }

        function hexToRgba(hex, alpha) {
            let c;
            if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                c = hex.substring(1).split('');
                if (c.length === 3) {
                    c = [c[0], c[0], c[1], c[1], c[2], c[2]];
                }
                c = '0x' + c.join('');
                return `rgba(${[(c >> 16) & 255, (c >> 8) & 255, c & 255].join(',')},${alpha})`;
            }
             // Fallback for named colors, won't support alpha but won't crash
            return hex;
        }


        // --- Drawing Logic ---
        function createSvgElement(tag, attrs) {
            const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (const key in attrs) el.setAttribute(key, attrs[key]);
            return el;
        }

        function drawObject(svg, obj, color, isInverted = false) {
            let tempObj = obj;
            if (obj.type.endsWith('-temp')) {
                const p1 = getPointById(obj.p1Id || obj.centerId);
                if (!p1) return;
                if (obj.type === 'line-temp') tempObj = { type: 'line', p1: p1, p2: obj.p2, id: -1 };
                else {
                    const r = Math.sqrt((obj.radiusPt.x - p1.x)**2 + (obj.radiusPt.y - p1.y)**2);
                    tempObj = { type: 'circle', cx: p1.x, cy: p1.y, r: r, id: -1 };
                }
            }
            
            const rgbaColor = hexToRgba(color.hex, color.alpha);

            const transform = `translate(${svg.clientWidth / 2} ${svg.clientHeight / 2}) scale(${camera.zoom}) translate(${camera.x} ${camera.y})`;
            let element;
            
            switch (tempObj.type) {
                case 'point': {
                    element = createSvgElement('circle', { cx: tempObj.x, cy: tempObj.y, r: 1.7 / camera.zoom, fill: 'black', stroke: 'black', 'stroke-width': 0.5 / camera.zoom, transform, 'data-id': tempObj.id });
                    break;
                }
                case 'line': {
                    let p1 = tempObj.p1, p2 = tempObj.p2;
                    if(tempObj.p1Id !== undefined) { p1 = getPointById(tempObj.p1Id); p2 = getPointById(tempObj.p2Id); }
                    if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p2.x)) return;
                    
                    element = createSvgElement('g', { transform, 'data-id': tempObj.id });
                    
                    const solidLine = createSvgElement('line', { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, stroke: rgbaColor, 'stroke-width': 3 / camera.zoom });
                    element.appendChild(solidLine);

                    const dx = p2.x - p1.x, dy = p2.y - p1.y, len = Math.sqrt(dx*dx + dy*dy);
                    if (len > 1e-6) {
                        const L = 10000, udx = dx / len, udy = dy / len;
                        const ext1 = createSvgElement('line', { x1: p2.x, y1: p2.y, x2: p2.x + udx * L, y2: p2.y + udy * L, stroke: rgbaColor, 'stroke-width': 3 / camera.zoom, 'stroke-dasharray': `${8 / camera.zoom} ${4 / camera.zoom}`});
                        const ext2 = createSvgElement('line', { x1: p1.x, y1: p1.y, x2: p1.x - udx * L, y2: p1.y - udy * L, stroke: rgbaColor, 'stroke-width': 3 / camera.zoom, 'stroke-dasharray': `${8 / camera.zoom} ${4 / camera.zoom}`});
                        element.appendChild(ext1);
                        element.appendChild(ext2);
                    }
                    break;
                }
                case 'circle': {
                    let { cx, cy, r } = tempObj;
                    if(tempObj.centerId !== undefined) {
                        const center = getPointById(tempObj.centerId), radiusPt = getPointById(tempObj.radiusId);
                        if(!center || !radiusPt) return;
                        cx = center.x; cy = center.y;
                        r = Math.sqrt((radiusPt.x - center.x)**2 + (radiusPt.y - center.y)**2);
                    }
                    if (r === undefined || !isFinite(cx) || !isFinite(r)) return;
                    element = createSvgElement('circle', { cx, cy, r, stroke: rgbaColor, 'stroke-width': 3/camera.zoom, fill: 'none', transform, 'data-id': tempObj.id });
                    break;
                }
            }
             if (element) {
                if (isInverted) element.classList.add('inverted-object');
                svg.appendChild(element);
            }
        }
        
        function drawInversionCircle(svg) {
            const transform = `translate(${svg.clientWidth / 2} ${svg.clientHeight / 2}) scale(${camera.zoom}) translate(${camera.x} ${camera.y})`;
            svg.appendChild(createSvgElement('circle', { cx: INVERSION_CENTER.x, cy: INVERSION_CENTER.y, r: INVERSION_RADIUS, stroke: '#aaa', 'stroke-width': 1.5/camera.zoom, fill: 'none', 'stroke-dasharray': `${8/camera.zoom} ${4/camera.zoom}`, transform }));
        }

        function drawOrigin(svg) {
            const transform = `translate(${svg.clientWidth/2} ${svg.clientHeight/2}) scale(${camera.zoom}) translate(${camera.x} ${camera.y})`;
            const group = createSvgElement('g', { transform, 'stroke-width': 1/camera.zoom, stroke: '#888' });
            group.appendChild(createSvgElement('line', { x1: -5/camera.zoom, y1: 0, x2: 5/camera.zoom, y2: 0 }));
            group.appendChild(createSvgElement('line', { x1: 0, y1: -5/camera.zoom, x2: 0, y2: 5/camera.zoom }));
            svg.appendChild(group);
        }
        
        function drawSnapHighlight(svg, point) {
            const transform = `translate(${svg.clientWidth/2} ${svg.clientHeight/2}) scale(${camera.zoom}) translate(${camera.x} ${camera.y})`;
            svg.appendChild(createSvgElement('circle', { cx: point.x, cy: point.y, r: 10/camera.zoom, fill: 'none', stroke: '#007bff', 'stroke-width': 2/camera.zoom, transform }));
        }
        
        function updateDependentPoints() {
            let changed = false;
            objects.forEach(obj => {
                if (obj.type === 'point' && obj.dependency) {
                    let newPos;
                    if (obj.dependency.type === 'inversion') {
                        const target = getPointById(obj.dependency.targetId);
                        if (target) newPos = invertPoint(target);
                    }
                    if (newPos && (obj.x !== newPos.x || obj.y !== newPos.y)) {
                        obj.x = newPos.x;
                        obj.y = newPos.y;
                        changed = true;
                    }
                }
            });
            return changed;
        }


        function render() {
            if (updateDependentPoints()) {
                // If dependencies changed, just re-render without creating a loop
            }
            requestAnimationFrame(() => {
                inputSvg.innerHTML = '';
                outputSvg.innerHTML = '';

                if (viewMode === 'split') {
                    drawOrigin(inputSvg);
                    drawInversionCircle(inputSvg);
                    drawOrigin(outputSvg);
                    drawInversionCircle(outputSvg);

                    objects.forEach(obj => {
                        drawObject(inputSvg, obj, colors.input);
                        drawObject(outputSvg, invertObject(obj), colors.output, true);
                    });
                } else { // Integrated mode
                    drawOrigin(inputSvg);
                    drawInversionCircle(inputSvg);
                    objects.forEach(obj => {
                        drawObject(inputSvg, obj, colors.input);
                        drawObject(inputSvg, invertObject(obj), colors.output, true);
                    });
                }
                
                const showSnap = snapPoint && (activeTool !== 'select' || constructionState.tool);
                if (showSnap) drawSnapHighlight(inputSvg, snapPoint);
                if (constructionState.tempPoint) drawObject(inputSvg, constructionState.tempPoint, {hex: colors.input.hex, alpha: 0.5 });
            });
        }
        
        // --- Tool & Construction Logic ---
        function getGeom(obj, getInverted = false) {
             const targetObj = getInverted ? invertObject(obj) : obj;
             if (targetObj.type === 'none') return null;

             switch(targetObj.type) {
                case 'line': {
                    let p1 = targetObj.p1, p2 = targetObj.p2;
                    if(targetObj.p1Id !== undefined) { p1 = getPointById(targetObj.p1Id); p2 = getPointById(targetObj.p2Id); }
                    if (!p1 || !p2) return null;
                    return { type: 'line', p1, p2, originalId: obj.id, isInverted: getInverted };
                }
                case 'circle': {
                    let { cx, cy, r } = targetObj;
                    if(targetObj.centerId !== undefined) {
                        const center = getPointById(targetObj.centerId), radiusPt = getPointById(targetObj.radiusId);
                        if(!center || !radiusPt) return null;
                        cx = center.x; cy = center.y;
                        r = Math.sqrt((radiusPt.x - center.x)**2 + (radiusPt.y - center.y)**2);
                    }
                    if (r === undefined || !isFinite(cx)) return null;
                    return { type: 'circle', center: {x: cx, y: cy}, r, originalId: obj.id, isInverted: getInverted };
                }
                default: return null;
            }
        }

        function lineLineIntersection(l1, l2) {
            const d = (l1.p1.x - l1.p2.x) * (l2.p1.y - l2.p2.y) - (l1.p1.y - l1.p2.y) * (l2.p1.x - l2.p2.x);
            if (Math.abs(d) < 1e-9) return null;

            const t = ((l1.p1.x - l2.p1.x) * (l2.p1.y - l2.p2.y) - (l1.p1.y - l2.p1.y) * (l2.p1.x - l2.p2.x)) / d;
            return { x: l1.p1.x + t * (l1.p2.x - l1.p1.x), y: l1.p1.y + t * (l1.p2.y - l1.p1.y) };
        }

        function lineCircleIntersections(line, circle) {
            const { p1, p2 } = line; const { center, r } = circle;
            const dx = p2.x - p1.x, dy = p2.y - p1.y, A = dx * dx + dy * dy;
            const B = 2 * (dx * (p1.x - center.x) + dy * (p1.y - center.y));
            const C = (p1.x - center.x)**2 + (p1.y - center.y)**2 - r * r;
            const det = B * B - 4 * A * C;
            if (det < 1e-9) return [];
            const results = [];
            const t1 = (-B + Math.sqrt(det)) / (2 * A);
            results.push({ x: p1.x + t1 * dx, y: p1.y + t1 * dy });
            if (det > 1e-9) {
                const t2 = (-B - Math.sqrt(det)) / (2 * A);
                results.push({ x: p1.x + t2 * dx, y: p1.y + t2 * dy });
            }
            return results;
        }

        function circleCircleIntersections(c1, c2) {
            const { center: cen1, r: r1 } = c1; const { center: cen2, r: r2 } = c2;
            const dx = cen2.x - cen1.x, dy = cen2.y - cen1.y, d = Math.sqrt(dx*dx + dy*dy);
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return [];
            const a = (r1*r1 - r2*r2 + d*d) / (2 * d);
            const h = Math.sqrt(Math.max(0, r1*r1 - a*a));
            const x2 = cen1.x + a * (dx / d), y2 = cen1.y + a * (dy / d);
            const results = [{ x: x2 + h * (dy / d), y: y2 - h * (dx / d) }];
            if (h > 1e-9) results.push({ x: x2 - h * (dy / d), y: y2 + h * (dx / d) });
            return results;
        }

        function getAllIntersections(worldPos) {
            const allGeom = [];
            objects.forEach(obj => {
                const geom = getGeom(obj, false);
                if (geom) allGeom.push(geom);
                if (viewMode === 'integrated') {
                    const invertedGeom = getGeom(obj, true);
                    if (invertedGeom) allGeom.push(invertedGeom);
                }
            });
            allGeom.push({ type: 'circle', center: INVERSION_CENTER, r: INVERSION_RADIUS, originalId: -1, isInverted: false });
            
            const intersections = [];
            for (let i = 0; i < allGeom.length; i++) {
                for (let j = i + 1; j < allGeom.length; j++) {
                    const g1 = allGeom[i], g2 = allGeom[j];
                    if (g1.type === 'line' && g2.type === 'line') {
                        const p = lineLineIntersection(g1, g2); if (p) intersections.push(p);
                    } else if (g1.type === 'line' && g2.type === 'circle') {
                        intersections.push(...lineCircleIntersections(g1, g2));
                    } else if (g1.type === 'circle' && g2.type === 'line') {
                        intersections.push(...lineCircleIntersections(g2, g1));
                    } else if (g1.type === 'circle' && g2.type === 'circle') {
                        intersections.push(...circleCircleIntersections(g1, g2));
                    }
                }
            }
            return intersections;
        }
        
        function getClosestPointObject(worldPos) {
            let closestPoint = null;
            let min_dist_sq = (5 / camera.zoom)**2;
            
            const origin = { type: 'point', id: 0, x: INVERSION_CENTER.x, y: INVERSION_CENTER.y };
            const distSqOrigin = (worldPos.x - origin.x)**2 + (worldPos.y - origin.y)**2;
            if (distSqOrigin < min_dist_sq) {
                min_dist_sq = distSqOrigin;
                closestPoint = origin;
            }

            for (const obj of objects) {
                if (obj.type === 'point' && !obj.dependency) {
                    const distSq = (obj.x - worldPos.x)**2 + (obj.y - worldPos.y)**2;
                    if (distSq < min_dist_sq) {
                        min_dist_sq = distSq;
                        closestPoint = obj;
                    }
                }
            }
            return closestPoint;
        }

        function getSnapPoint(worldPos) {
            const snapRadiusSq = (5 / camera.zoom)**2;

            let closestSnap = null;
            let minSnapDistSq = snapRadiusSq;

            // P1: Manual points & Origin
            const closestManualPoint = getClosestPointObject(worldPos);
            if (closestManualPoint) {
                 const distSq = (closestManualPoint.x - worldPos.x)**2 + (closestManualPoint.y - worldPos.y)**2;
                 if (distSq < minSnapDistSq) {
                     minSnapDistSq = distSq;
                     closestSnap = closestManualPoint;
                 }
            }

            // P1: Intersections
            const intersections = getAllIntersections();
            for (const p of intersections) {
                const distSq = (p.x - worldPos.x)**2 + (p.y - worldPos.y)**2;
                if (distSq < minSnapDistSq) {
                    minSnapDistSq = distSq;
                    closestSnap = p;
                }
            }
            if (closestSnap) return closestSnap;

            // P2: Inverted points (integrated view only)
            if (viewMode === 'integrated') {
                 for (const obj of objects) {
                    if (obj.type === 'point') {
                        const p_inv = invertPoint(obj);
                        const distSq = (p_inv.x - worldPos.x)**2 + (p_inv.y - worldPos.y)**2;
                        if (distSq < minSnapDistSq) {
                            minSnapDistSq = distSq;
                            closestSnap = { ...p_inv, dependency: { type: 'inversion', targetId: obj.id }};
                        }
                    }
                }
            }
            if (closestSnap) return closestSnap;

            // P3: On-shape projections
            const allGeom = [];
            objects.forEach(obj => {
                const geom = getGeom(obj, false); if (geom) allGeom.push(geom);
                if (viewMode === 'integrated') { const invertedGeom = getGeom(obj, true); if (invertedGeom) allGeom.push(invertedGeom); }
            });
            allGeom.push({ type: 'circle', center: INVERSION_CENTER, r: INVERSION_RADIUS, originalId: -1, isInverted: false });
            
            for (const geom of allGeom) {
                let closestPtOnShape = null;
                if (geom.type === 'line') {
                    const l2 = (geom.p1.x - geom.p2.x)**2 + (geom.p1.y - geom.p2.y)**2; if (l2 < 1e-9) continue;
                    const t = ((worldPos.x - geom.p1.x) * (geom.p2.x - geom.p1.x) + (worldPos.y - geom.p1.y) * (geom.p2.y - geom.p1.y)) / l2;
                    closestPtOnShape = { x: geom.p1.x + t * (geom.p2.x - geom.p1.x), y: geom.p1.y + t * (geom.p2.y - geom.p1.y) };
                } else if (geom.type === 'circle') {
                    const dx = worldPos.x - geom.center.x, dy = worldPos.y - geom.center.y, dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 1e-6) closestPtOnShape = { x: geom.center.x + (dx / dist) * geom.r, y: geom.center.y + (dy / dist) * geom.r };
                }
                if (closestPtOnShape) {
                    const distSq = (worldPos.x - closestPtOnShape.x)**2 + (worldPos.y - closestPtOnShape.y)**2;
                    if (distSq < minSnapDistSq) {
                        minSnapDistSq = distSq;
                        closestSnap = closestPtOnShape;
                    }
                }
            }
            
            return closestSnap;
        }

        function getObjectAt(worldPos, typeFilter = null) {
            if (!typeFilter || typeFilter === 'point') {
                const point = getClosestPointObject(worldPos);
                if (point) return point;
            }
            if (typeFilter === 'point') return null;
            
            let closest = null;
            let min_dist_sq = (5 / camera.zoom)**2;
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                if (typeFilter && obj.type !== typeFilter) continue;
                let distSq;
                switch (obj.type) {
                    case 'point': continue;
                    case 'line': {
                        const p1 = getPointById(obj.p1Id), p2 = getPointById(obj.p2Id); if (!p1||!p2) continue;
                        const l2=(p1.x-p2.x)**2+(p1.y-p2.y)**2;
                        if(l2===0) distSq=(worldPos.x-p1.x)**2+(worldPos.y-p1.y)**2;
                        else {
                            let t = ((worldPos.x-p1.x)*(p2.x-p1.x)+(worldPos.y-p1.y)*(p2.y-p1.y))/l2;
                            distSq=(worldPos.x-(p1.x+t*(p2.x-p1.x)))**2+(worldPos.y-(p1.y+t*(p2.y-p1.y)))**2;
                        }
                        break;
                    }
                    case 'circle': {
                        const center = getPointById(obj.centerId), radiusPt = getPointById(obj.radiusId); if(!center||!radiusPt) continue;
                        const r = Math.sqrt((radiusPt.x-center.x)**2+(radiusPt.y-center.y)**2);
                        const distToCenter = Math.sqrt((worldPos.x-center.x)**2+(worldPos.y-center.y)**2);
                        distSq=(Math.abs(distToCenter-r))**2;
                        break;
                    }
                }
                if (distSq < min_dist_sq) { min_dist_sq = distSq; closest = obj; }
            }
            return closest;
        }

        function resetConstruction() {
            constructionState = { tool: null, step: 0, selections: [], tempPoint: null };
            updateInfoText();
        }

        function updateInfoText() {
            let text = '';
            switch(constructionState.tool) {
                case 'perp_bisector': text = `수직이등분선: ${constructionState.step === 0 ? '첫 번째 점' : '두 번째 점'}을 선택하세요.`; break;
                case 'perp_from_point': text = `수선 (점에서 직선으로): ${constructionState.step === 0 ? '기준 점' : '기준 직선'}을 선택하세요.`; break;
                case 'perp_on_line': text = `수선 (직선 위의 점에서): ${constructionState.step === 0 ? '기준 직선' : '직선 위의 기준 점'}을 선택하세요.`; break;
                case 'angle_bisector': text = `각의 이등분선: ${constructionState.step === 0 ? '각의 한 점' : (constructionState.step === 1 ? '꼭짓점' : '각의 다른 한 점')}을 선택하세요.`; break;
            }
            infoBox.textContent = text;
            infoBox.style.display = text ? 'block' : 'none';
        }
        
        function handleConstructionClick(worldPos) {
            const { tool, step, selections } = constructionState;
            
            // For tools that need a point
            if (tool === 'perp_bisector' || tool === 'angle_bisector' || (tool === 'perp_from_point' && step === 0) || (tool === 'perp_on_line' && step === 1)) {
                const snapTarget = getSnapPoint(worldPos);
                if (!snapTarget) return;

                let targetPoint;
                if (snapTarget.id !== undefined) {
                    targetPoint = snapTarget;
                } else {
                    targetPoint = { type: 'point', id: nextId++, x: snapTarget.x, y: snapTarget.y, dependency: snapTarget.dependency || null };
                    objects.push(targetPoint);
                }

                if(selections.some(sel => sel.id === targetPoint.id)) return;
                
                selections.push(targetPoint);
                constructionState.step++;

            // For tools that need a line
            } else if ((tool === 'perp_from_point' && step === 1) || (tool === 'perp_on_line' && step === 0)) {
                const clickedLine = getObjectAt(worldPos, 'line');
                if (!clickedLine) return;
                
                if(selections.some(sel => sel.id === clickedLine.id)) return;
                selections.push(clickedLine);
                constructionState.step++;
            } else {
                return;
            }

            // Execute construction logic
            if (tool === 'perp_bisector' && step === 1) {
                saveState();
                const [p1, p2] = selections;
                const midX = (p1.x + p2.x)/2, midY = (p1.y + p2.y)/2, dx = p2.x - p1.x, dy = p2.y - p1.y;
                const p3 = {type:'point', id:nextId++, x:midX-dy, y:midY+dx, dependency: null}, p4 = {type:'point', id:nextId++, x:midX+dy, y:midY-dx, dependency: null};
                objects.push(p3, p4, {type:'line', id:nextId++, p1Id: p3.id, p2Id: p4.id});
                resetConstruction();
            } else if (tool === 'perp_from_point' && step === 1) {
                saveState();
                const [point, line] = selections;
                const pA=getPointById(line.p1Id), pB=getPointById(line.p2Id);
                const l2=(pA.x-pB.x)**2 + (pA.y-pB.y)**2; if(l2 < 1e-9) { resetConstruction(); return; }
                const t=((point.x-pA.x)*(pB.x-pA.x)+(point.y-pA.y)*(pB.y-pA.y))/l2;
                const projPoint={type:'point',id:nextId++,x:pA.x+t*(pB.x-pA.x),y:pA.y+t*(pB.y-pA.y), dependency: null};
                objects.push(projPoint, {type:'line',id:nextId++,p1Id:point.id,p2Id:projPoint.id});
                resetConstruction();
            } else if (tool === 'perp_on_line' && step === 1) {
                saveState();
                const [line, point] = selections;
                const pA=getPointById(line.p1Id), pB=getPointById(line.p2Id);
                const dx=pB.x-pA.x, dy=pB.y-pA.y;
                const p_end={type:'point',id:nextId++,x:point.x-dy,y:point.y+dx, dependency: null};
                objects.push(p_end, {type:'line',id:nextId++,p1Id:point.id,p2Id:p_end.id});
                resetConstruction();
            } else if (tool === 'angle_bisector' && step === 2) {
                saveState();
                const [pA, pB, pC] = selections; // pB is vertex
                const v1x=pA.x-pB.x, v1y=pA.y-pB.y, v2x=pC.x-pB.x, v2y=pC.y-pB.y;
                const l1=Math.sqrt(v1x*v1x+v1y*v1y), l2=Math.sqrt(v2x*v2x+v2y*v2y);
                if(l1 < 1e-9 || l2 < 1e-9){ resetConstruction(); return; }
                const bisectorX=(v1x/l1)+(v2x/l2), bisectorY=(v1y/l1)+(v2y/l2);
                const p_end={type:'point',id:nextId++,x:pB.x+bisectorX,y:pB.y+bisectorY, dependency: null};
                objects.push(p_end, {type:'line',id:nextId++,p1Id:pB.id,p2Id:p_end.id});
                resetConstruction();
            }
            
            updateInfoText();
            render();
        }

        function handleMouseDown(e) {
            if (e.target.closest('#toolbar') || e.target.closest('.color-picker-wrapper') || e.target.closest('#history-controls') || e.target.closest('#view-toggle')) return;
            const worldPos = screenToWorld(inputSvg, e.clientX, e.clientY);
            if (e.ctrlKey) { dragInfo.camera = true; dragInfo.start = { x: e.clientX, y: e.clientY }; return; }
            
            if (constructionState.tool) { handleConstructionClick(worldPos); return; }

            switch (activeTool) {
                case 'select':
                    dragInfo.target = getObjectAt(worldPos, 'point');
                    if (dragInfo.target && dragInfo.target.id !== 0 && !dragInfo.target.dependency) {
                        saveState(); // Save state before starting the move
                        dragInfo.moved = false;
                    } else {
                        dragInfo.target = null;
                    }
                    break;
                case 'point': {
                    saveState();
                    const snapLocation = getSnapPoint(worldPos);
                    const coords = snapLocation || worldPos;
                    objects.push({ type: 'point', id: nextId++, x: coords.x, y: coords.y, dependency: snapLocation?.dependency || null });
                    render();
                    break;
                }
                case 'line': case 'circle': {
                    let currentSnap = getSnapPoint(worldPos), targetPoint;
                    if (currentSnap && currentSnap.id !== undefined) {
                        targetPoint = currentSnap;
                    } else {
                        saveState(); // Save state when adding a new point implicitly
                        const coords = currentSnap || worldPos;
                        targetPoint = { type: 'point', id: nextId++, x: coords.x, y: coords.y, dependency: currentSnap?.dependency || null };
                        objects.push(targetPoint);
                    }
                    if (!constructionState.tempPoint) {
                         constructionState.tempPoint = { type: (activeTool==='line'?'line-temp':'circle-temp'), p1Id: targetPoint.id, radiusPt: targetPoint, p2: targetPoint, centerId: targetPoint.id };
                    } else {
                        if (targetPoint.id !== constructionState.tempPoint.p1Id) {
                            if (!currentSnap || currentSnap.id === undefined) {
                                // Handled by first save
                            } else {
                                saveState();
                            }
                            if (activeTool==='line') objects.push({ type: 'line', id: nextId++, p1Id: constructionState.tempPoint.p1Id, p2Id: targetPoint.id });
                            else objects.push({ type: 'circle', id: nextId++, centerId: constructionState.tempPoint.centerId, radiusId: targetPoint.id });
                            constructionState.tempPoint = null;
                        }
                    }
                    render();
                    break;
                }
                case 'delete': {
                    const objectToDelete = getObjectAt(worldPos);
                    if (objectToDelete && objectToDelete.id !== 0) {
                        saveState();
                        let idsToDelete = new Set([objectToDelete.id]);
                        if (objectToDelete.type === 'point') {
                            objects.forEach(obj => {
                                if (['line', 'circle'].includes(obj.type) && [obj.p1Id, obj.p2Id, obj.centerId, obj.radiusId].includes(objectToDelete.id)) {
                                    idsToDelete.add(obj.id);
                                }
                            });
                        }
                        objects = objects.filter(obj => !idsToDelete.has(obj.id));
                    }
                    render();
                    break;
                }
            }
        }
        
        function handleMouseMove(e) {
            const worldPos = screenToWorld(inputSvg, e.clientX, e.clientY);
            snapPoint = getSnapPoint(worldPos);
            if (dragInfo.camera) {
                const dx = (e.clientX - dragInfo.start.x)/camera.zoom, dy = (e.clientY - dragInfo.start.y)/camera.zoom;
                camera.x += dx; camera.y += dy;
                dragInfo.start = { x: e.clientX, y: e.clientY };
                render(); return;
            }
            if (dragInfo.target) {
                dragInfo.target.x = worldPos.x;
                dragInfo.target.y = worldPos.y; 
                dragInfo.moved = true;
                render();
            }
            if (constructionState.tempPoint) {
                const finalPos = snapPoint || worldPos;
                constructionState.tempPoint.p2 = finalPos;
                constructionState.tempPoint.radiusPt = finalPos;
                render();
            } else if (!dragInfo.target) {
                render();
            }
        }
        
        function handleMouseUp(e) {
            if (dragInfo.target && !dragInfo.moved) {
                undoStack.pop();
                updateHistoryButtons();
            }
            dragInfo = { target: null, start: null, camera: false, moved: false };
        }
        
        function handleWheel(e) {
            e.preventDefault();
            if (e.ctrlKey) {
                const p1 = screenToWorld(inputSvg, e.clientX, e.clientY);
                camera.zoom *= (e.deltaY < 0) ? 1.1 : 1/1.1;
                const p2 = screenToWorld(inputSvg, e.clientX, e.clientY);
                camera.x += p1.x - p2.x; camera.y += p1.y - p2.y;
            } else if (e.shiftKey) camera.x -= e.deltaY / camera.zoom;
            else camera.y -= e.deltaY / camera.zoom;
            render();
        }

        // --- Event Listeners & Setup ---
        function setupColorPicker(pickerElement, colorKey) {
            if (!pickerElement) return;
            const btn = pickerElement.querySelector('.color-picker-btn');
            const popup = pickerElement.querySelector('.color-picker-popup');
            const input = pickerElement.querySelector('.color-picker-input');
            const slider = pickerElement.querySelector('.opacity-slider');
            
            btn.style.backgroundColor = colors[colorKey].hex;
            
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                popup.style.display = popup.style.display === 'flex' ? 'none' : 'flex';
                input.value = colors[colorKey].hex;
                slider.value = colors[colorKey].alpha;
            });
            
            input.addEventListener('input', () => {
                const newHex = input.value.trim();
                 if (/^#([0-9A-F]{3}){1,2}$/i.test(newHex) || /^[a-z]+$/i.test(newHex)) {
                    colors[colorKey].hex = newHex;
                    document.querySelectorAll(`.color-picker[data-colorkey="${colorKey}"] .color-picker-btn`).forEach(b => b.style.backgroundColor = newHex);
                    render();
                }
            });

            slider.addEventListener('input', () => {
                colors[colorKey].alpha = parseFloat(slider.value);
                render();
            });

            pickerElement.setAttribute('data-colorkey', colorKey);
        }

        function setupEventListeners() {
            contentWrapper.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            contentWrapper.addEventListener('wheel', handleWheel, { passive: false });

            document.body.addEventListener('click', () => {
                 document.querySelectorAll('.color-picker-popup').forEach(p => p.style.display = 'none');
            });

            toolbar.addEventListener('click', e => {
                const button = e.target.closest('.tool-button'); if (!button) return;
                resetConstruction();
                constructionState.tempPoint = null;
                if (button.id === 'reset-button') {
                    saveState();
                    objects = [];
                    render();
                } else {
                    activeTool = button.dataset.tool;
                    if (activeTool.includes('perp_') || activeTool.includes('bisector')) {
                        constructionState.tool = activeTool;
                    } else {
                        constructionState.tool = null;
                    }
                    document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    updateInfoText(); render();
                }
            });
            
            toggleButton.addEventListener('click', () => {
                document.body.classList.toggle('toolbar-closed');
                toggleButton.innerHTML = document.body.classList.contains('toolbar-closed') ? '&gt;' : '&lt;';
                setTimeout(() => window.dispatchEvent(new Event('resize')), 300);
            });
            
            viewToggle.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    viewMode = e.target.dataset.mode;
                    document.body.classList.toggle('integrated-view', viewMode === 'integrated');
                    document.querySelectorAll('#view-toggle button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    window.dispatchEvent(new Event('resize')); 
                }
            });

            window.addEventListener('resize', render);
            window.addEventListener('keydown', e => {
                if (document.activeElement.tagName === 'INPUT') return;
                
                if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) { redo(); } else { undo(); }
                    return;
                }

                let tool;
                switch(e.key.toLowerCase()) {
                    case 'v': tool='select'; break; case 'p': tool='point'; break; case 'l': tool='line'; break; case 'c': tool='circle'; break; case 'i': tool='intersection'; break;
                    case 'd': case 'delete': tool='delete'; break; case 'r': resetButton.click(); return; default: return;
                }
                e.preventDefault();
                document.querySelector(`.tool-button[data-tool="${tool}"]`).click();
            });
            
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            
            setupColorPicker(document.getElementById('input-color-picker'), 'input');
            setupColorPicker(document.getElementById('output-color-picker-integrated'), 'output');
            setupColorPicker(document.getElementById('output-color-picker-split'), 'output');
        }
        
        // --- Initialization ---
        document.querySelector('.tool-button[data-tool="select"]').classList.add('active');
        saveState(true); // Save initial empty state
        updateHistoryButtons();
        setupEventListeners();
        render();
    </script>
</body>
</html>

